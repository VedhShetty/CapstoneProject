package com.banking.service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.banking.model.Account;
import com.banking.model.Transaction;
import com.banking.repository.AccountRepository;
import com.banking.repository.TransactionRepository;

@Service
@Transactional
public class TransactionService {
	
	@Autowired
	private TransactionRepository transactionRepository;
	
	@Autowired
	private AccountRepository accountRepository;
	
	public Transaction deposit(String accountNumber, BigDecimal amount, String description) {
		
		if (amount.compareTo(BigDecimal.ZERO)<=0) {
			throw new RuntimeException("Deposit amount must be greater than zero");
		}
		
		Account account = accountRepository.findByAccountNumber(accountNumber)
				.orElseThrow(() -> new RuntimeException("Account not found with number: "+accountNumber));
		if (!"ACTIVE".equals(account.getStatus())) {
			throw new RuntimeException("Cannot deposit to "+account.getStatus().toLowerCase()+" account");
		}
		
		BigDecimal newBalance = account.getBalance().add(amount);
		account.setBalance(newBalance);
		accountRepository.save(account);
		
		Transaction transaction = new Transaction(accountNumber, "DEPOSIT", amount, description);
		transaction.setStatus("SUCCESS");
		
		return transactionRepository.save(transaction);
	}
	
	public Transaction withdraw(String accountNumber, BigDecimal amount, String description) {
		if(amount.compareTo(BigDecimal.ZERO)<=0) {
			throw new RuntimeException("Withdrawal amount must be greater than zero");
		}
		Account account = accountRepository.findByAccountNumber(accountNumber)
				.orElseThrow(() -> new RuntimeException("Account not found with number: "+accountNumber));
		if (!"ACTIVE".equals(account.getStatus())) {
			throw new RuntimeException("Cannot withdraw from "+account.getStatus().toLowerCase()+" account");
		}
		
		if (account.getBalance().compareTo(amount)<0) {
			Transaction failedTransaction = new Transaction(accountNumber, "WITHDRAWAL", amount, description);
			failedTransaction.setStatus("Failed");
			transactionRepository.save(failedTransaction);
			throw new RuntimeException("Insufficient balance. Available balance: "+account.getBalance());
		}
		BigDecimal newBalance = account.getBalance().subtract(amount);
		account.setBalance(newBalance);
		accountRepository.save(account);
		Transaction transaction = new Transaction(accountNumber, "WITHDRAWAL", amount, description);
		transaction.setStatus("SUCCESS");
		return transactionRepository.save(transaction);
	}
	
	public List<Transaction> getAllTransactions(){
		return transactionRepository.findAll();
	}
	
	public List<Transaction> getTransactionsByAccountNumber(String accountNumber){
		return transactionRepository.findByAccountNumberOrderByTransactionTimeDesc(accountNumber);
	}
	
	public Transaction getTransactionById(Long transactionId) {
		return transactionRepository.findById(transactionId)
				.orElseThrow(() -> new RuntimeException("Transaction not found with id: "+transactionId));
	}
	
	public List<Transaction> getTransactionsByType(String transactionType){
		return transactionRepository.findByTransactionsType(transactionType);
	}
	
	public List<Transaction> getTransactionsByStatus(String status){
		return transactionRepository.findByStatus(status);
	}
	
	public List<Transaction> getTransactionsByAccountAndDateRange(
			String accountNumber,
			LocalDateTime startDate,
			LocalDateTime endDate){
		return transactionRepository.findByAccountNumberAndTransactionTimeBetween(accountNumber, startDate, endDate);
	}
	
	public List<Transaction> getTransactionByDateRange(
			LocalDateTime startDate,
			LocalDateTime endDate){
		return transactionRepository.findByTransactionTimeBetween(startDate, endDate);
	}
}
