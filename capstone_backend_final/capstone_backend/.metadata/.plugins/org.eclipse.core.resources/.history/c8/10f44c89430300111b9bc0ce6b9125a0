package com.banking.controller;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.banking.model.Account;
import com.banking.model.Transaction;
import com.banking.service.AccountService;
import com.banking.service.RoleValidator;
import com.banking.service.TransactionService;

@RestController
@RequestMapping("/api/transactions")
@CrossOrigin(origins = "http://localhost:4200")
public class TransactionController {

	@Autowired
	private TransactionService transactionService;

	@Autowired
	private AccountService accountService;

	@Autowired
	private RoleValidator roleValidator;

	@PostMapping("/deposit")
	public ResponseEntity<?> deposit(@RequestBody Map<String, Object> request, @RequestHeader("userRole") String role) {
		try {
			roleValidator.validateAdmin(role);

			String accountNumber = (String) request.get("accountNumber");
			BigDecimal amount = new BigDecimal(request.get("amount").toString());
			String description = (String) request.getOrDefault("description", "Deposit");

			Transaction transaction = transactionService.deposit(accountNumber, amount, description);
			Account account = accountService.getAccountByNumber(accountNumber)
					.orElseThrow(() -> new RuntimeException("Account not found"));

			Map<String, Object> response = new HashMap<>();
			response.put("success", true);
			response.put("message", "Deposit successful");
			response.put("transaction", transaction);
			response.put("newBalance", account.getBalance());

			return ResponseEntity.status(HttpStatus.CREATED).body(response);
		} catch (Exception e) {
			Map<String, Object> response = new HashMap<>();
			response.put("success", false);
			response.put("message", e.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
		}
	}

	@PostMapping("/withdraw")
	public ResponseEntity<?> withdraw(@RequestBody Map<String, Object> request,
			@RequestHeader("userRole") String role) {
		try {
			roleValidator.validateAdmin(role);

			String accountNumber = (String) request.get("accountNumber");
			BigDecimal amount = new BigDecimal(request.get("amount").toString());
			String description = (String) request.getOrDefault("description", "Withdrawal");

			Transaction transaction = transactionService.withdraw(accountNumber, amount, description);

			Account account = accountService.getAccountByNumber(accountNumber)
					.orElseThrow(() -> new RuntimeException("Account not found"));

			Map<String, Object> response = new HashMap<>();
			response.put("success", true);
			response.put("message", "Withdrawal successful");
			response.put("transaction", transaction);
			response.put("newBalance", account.getBalance());

			return ResponseEntity.status(HttpStatus.CREATED).body(response);
		} catch (Exception e) {
			Map<String, Object> response = new HashMap<>();
			response.put("success", false);
			response.put("message", e.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
		}
	}

	@GetMapping
	public ResponseEntity<?> getAllTransactions(@RequestHeader("userRole") String role) {
		try {
			roleValidator.validateAdmin(role);

			List<Transaction> transactions = transactionService.getAllTransactions();

			Map<String, Object> response = new HashMap<>();
			response.put("success", true);
			response.put("transactions", transactions);
			response.put("count", transactions.size());

			return ResponseEntity.ok(response);
		} catch (Exception e) {
			Map<String, Object> response = new HashMap<>();
			response.put("success", false);
			response.put("message", e.getMessage());
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
		}
	}

	@GetMapping("/account/{accountNumber}")
	public ResponseEntity<?> getTransactionsByAccount(@PathVariable String accountNumber,
			@RequestHeader("userRole") String role, @RequestHeader("userId") Long loggedInUserId) {
		try {
			Account account = accountService.getAccountByNumber(accountNumber)
					.orElseThrow(() -> new RuntimeException("Account not found"));

			roleValidator.validateAccountAccess(role, account.getUserId(), loggedInUserId);

			List<Transaction> transactions = transactionService.getTransactionsByAccountNumber(accountNumber);

			Map<String, Object> response = new HashMap<>();
			response.put("success", true);
			response.put("transactions", transactions);
			response.put("count", transactions.size());

			return ResponseEntity.ok(response);
		} catch (Exception e) {
			Map<String, Object> response = new HashMap<>();
			response.put("success", false);
			response.put("message", e.getMessage());
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
		}
	}

	@GetMapping("/{transactionId}")
	public ResponseEntity<?> getTransactionById(@PathVariable Long transactionId,
			@RequestHeader("userRole") String role, @RequestHeader("userId") Long loggedInUserId) {
		try {
			Transaction transaction = transactionService.getTransactionById(transactionId);
			Account account = accountService.getAccountByNumber(transaction.getAccountNumber())
					.orElseThrow(() -> new RuntimeException("Account not found"));

			roleValidator.validateAccountAccess(role, account.getUserId(), loggedInUserId);

			Map<String, Object> response = new HashMap<>();
			response.put("success", true);
			response.put("transaction", transaction);

			return ResponseEntity.ok(response);
		} catch (Exception e) {
			Map<String, Object> response = new HashMap<>();
			response.put("success", false);
			response.put("message", e.getMessage());
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
		}
	}
	
	@GetMapping("/type/{transactionType}")
	public ResponseEntity<?> getTransactionsByType(@PathVariable String transactionType,
			@RequestHeader("userRole") String role) {
		try {
			roleValidator.validateAdmin(role);

			List<Transaction> transactions = transactionService.getTransactionsByType(transactionType);

			Map<String, Object> response = new HashMap<>();
			response.put("success", true);
			response.put("transactions", transactions);
			response.put("count", transactions.size());

			return ResponseEntity.ok(response);
		} catch (Exception e) {
			Map<String, Object> response = new HashMap<>();
			response.put("success", false);
			response.put("message", e.getMessage());
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
		}
	}

	@GetMapping("/status/{status}")
	public ResponseEntity<?> getTransactionsByStatus(@PathVariable String status,
			@RequestHeader("userRole") String role) {
		try {
			roleValidator.validateAdmin(role);

			List<Transaction> transactions = transactionService.getTransactionsByStatus(status);

			Map<String, Object> response = new HashMap<>();
			response.put("success", true);
			response.put("transactions", transactions);
			response.put("count", transactions.size());

			return ResponseEntity.ok(response);
		} catch (Exception e) {
			Map<String, Object> response = new HashMap<>();
			response.put("success", false);
			response.put("message", e.getMessage());
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
		}
	}
}
